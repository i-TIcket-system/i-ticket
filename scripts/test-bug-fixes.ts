/**
 * Comprehensive Test Script for 11 Bug Fixes
 * Run: npx tsx scripts/test-bug-fixes.ts
 */

import prisma from "../src/lib/db"

interface TestResult {
  name: string
  status: "PASS" | "FAIL" | "SKIP"
  message: string
}

const results: TestResult[] = []

function log(test: string, status: "PASS" | "FAIL" | "SKIP", message: string) {
  results.push({ name: test, status, message })
  const icon = status === "PASS" ? "âœ…" : status === "FAIL" ? "âŒ" : "â­ï¸"
  console.log(`${icon} ${test}: ${message}`)
}

async function testHomepageStatsAPI() {
  try {
    const response = await fetch("http://localhost:3000/api/homepage-stats")
    const data = await response.json()

    if (data.travelers && data.trips && data.destinations && data.companies) {
      log("Homepage Stats API", "PASS", `Returns: ${JSON.stringify(data)}`)
    } else {
      log("Homepage Stats API", "FAIL", "Missing fields in response")
    }
  } catch (error) {
    log("Homepage Stats API", "FAIL", `Error: ${error instanceof Error ? error.message : String(error)}`)
  }
}

async function testDefaultStaffCreation() {
  try {
    // Check if companies have staff
    const companies = await prisma.company.findMany({
      include: {
        _count: { select: { users: true } }
      },
      take: 5
    })

    const companiesWithoutStaff = companies.filter(c => c._count.users === 0)

    if (companiesWithoutStaff.length === 0) {
      log("Default Staff Creation", "PASS", "All companies have staff members")
    } else {
      log("Default Staff Creation", "SKIP", `${companiesWithoutStaff.length} companies without staff (need to test Setup Staff button)`)
    }

    // Check for manual ticketers
    const ticketers = await prisma.user.count({
      where: { staffRole: "MANUAL_TICKETER" }
    })

    if (ticketers > 0) {
      log("Manual Ticketers Exist", "PASS", `Found ${ticketers} manual ticketers in system`)
    } else {
      log("Manual Ticketers Exist", "FAIL", "No manual ticketers found!")
    }
  } catch (error) {
    log("Default Staff Creation", "FAIL", `Error: ${error instanceof Error ? error.message : String(error)}`)
  }
}

async function testDatabaseCounts() {
  try {
    const [customers, trips, cities, activeCompanies, allCompanies] = await Promise.all([
      prisma.user.count({ where: { role: "CUSTOMER" } }),
      prisma.trip.count(),
      prisma.city.count(),
      prisma.company.count({ where: { isActive: true } }),
      prisma.company.count()
    ])

    log("Database Counts", "PASS",
      `Customers: ${customers}, Trips: ${trips}, Cities: ${cities}, Active Companies: ${activeCompanies}/${allCompanies}`)
  } catch (error) {
    log("Database Counts", "FAIL", `Error: ${error instanceof Error ? error.message : String(error)}`)
  }
}

async function testSeatBookingErrorMessages() {
  try {
    // Find a trip with bookings
    const tripWithBookings = await prisma.trip.findFirst({
      where: {
        bookings: { some: { status: { not: "CANCELLED" } } }
      },
      include: {
        bookings: {
          where: { status: { not: "CANCELLED" } },
          include: {
            passengers: {
              where: { seatNumber: { not: null } },
              select: { seatNumber: true }
            }
          },
          take: 1
        }
      }
    })

    if (tripWithBookings && tripWithBookings.bookings[0]?.passengers[0]?.seatNumber) {
      const isQuickTicket = tripWithBookings.bookings[0].isQuickTicket
      const seatType = isQuickTicket ? "manual ticketing" : "online booking"
      log("Enhanced Error Messages", "PASS",
        `Trip ${tripWithBookings.id.slice(0, 8)} has occupied seat (${seatType})`)
    } else {
      log("Enhanced Error Messages", "SKIP", "No trips with occupied seats found for testing")
    }
  } catch (error) {
    log("Enhanced Error Messages", "FAIL", `Error: ${error instanceof Error ? error.message : String(error)}`)
  }
}

async function testStaffRoles() {
  try {
    const staffByRole = await prisma.user.groupBy({
      by: ['staffRole'],
      where: { role: "COMPANY_ADMIN", staffRole: { not: null } },
      _count: true
    })

    const rolesSummary = staffByRole.map(r => `${r.staffRole}: ${r._count}`).join(", ")

    if (staffByRole.length > 0) {
      log("Staff Roles Distribution", "PASS", rolesSummary)
    } else {
      log("Staff Roles Distribution", "FAIL", "No staff with defined roles found")
    }
  } catch (error) {
    log("Staff Roles Distribution", "FAIL", `Error: ${error instanceof Error ? error.message : String(error)}`)
  }
}

async function testAutoGeneratedStaff() {
  try {
    // Check for staff that must change password (auto-generated)
    const autoGeneratedStaff = await prisma.user.count({
      where: {
        mustChangePassword: true,
        role: "COMPANY_ADMIN"
      }
    })

    if (autoGeneratedStaff > 0) {
      log("Auto-Generated Staff Passwords", "PASS", `${autoGeneratedStaff} staff must change password on first login`)
    } else {
      log("Auto-Generated Staff Passwords", "SKIP", "No staff with mustChangePassword flag (all changed passwords)")
    }
  } catch (error) {
    log("Auto-Generated Staff Passwords", "FAIL", `Error: ${error instanceof Error ? error.message : String(error)}`)
  }
}

async function runAllTests() {
  console.log("\nðŸ§ª Running Comprehensive Bug Fix Tests...\n")
  console.log("=" .repeat(60))

  await testDatabaseCounts()
  await testHomepageStatsAPI()
  await testDefaultStaffCreation()
  await testStaffRoles()
  await testAutoGeneratedStaff()
  await testSeatBookingErrorMessages()

  console.log("=" .repeat(60))
  console.log("\nðŸ“Š Test Summary:\n")

  const passed = results.filter(r => r.status === "PASS").length
  const failed = results.filter(r => r.status === "FAIL").length
  const skipped = results.filter(r => r.status === "SKIP").length

  console.log(`âœ… Passed:  ${passed}`)
  console.log(`âŒ Failed:  ${failed}`)
  console.log(`â­ï¸  Skipped: ${skipped}`)
  console.log(`ðŸ“ Total:   ${results.length}`)

  if (failed > 0) {
    console.log("\nâŒ FAILED TESTS:")
    results.filter(r => r.status === "FAIL").forEach(r => {
      console.log(`   - ${r.name}: ${r.message}`)
    })
    process.exit(1)
  } else {
    console.log("\nâœ… All critical tests passed!")
    process.exit(0)
  }
}

runAllTests().catch(console.error)
